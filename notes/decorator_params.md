### Декораторы с параметрами
Существует возможность обернуть декоратор функцией с параметрами которые мы хотим ему передать. Например:

    from time import sleep
     
    def sleeper(secs):
        def decorator(fn):
            def wrapped(*args, **kwargs):
                sleep(secs)
                fn(*args, **kwargs)
     
            return wrapped
     
        return decorator

Затем его можно применить следующим образом:

    @sleeper(10)               # sleep for 10 secs 
    def say_hello(name):
        print("Hello {}!".format(name))
        
Или выполнить тоже самое такой строчкой:

    say_hello = sleeper(10)(say_hello)
    
Разберем последнюю конструкцию поподробней.

В начале, перед тем как будет декорироваться функция **`say_hello`** нужно  выполнить хитрый трюк и вызвать функцию **`sleeper`** с параметром `secs=10`. Внутри фукнции **`sleeper`** создается функция-декоратор с именем **`decorator`** которая затем просто возращается и подставляется на место строчки `sleeper(10)`.

То есть получиться такая подстановка справа от оператора присваивания:

    say_hello = sleeper(10)(say_hello)

->

    say_hello = decorator(say_hello)

Теперь когда уже будет вызываться функция **`decorator`**, декоратор будет знать, что значение переменной `secs` равно 10. Или иными словами она будет иметь доступ к локальной области видимости  функции **`sleeper`** которая хранит переменную `secs` равную числу 10. Несмотря на то, что эта функция уже отработала, ее значения по-прежнему доступны для **`decorator`**.

Внутри **`decorator`** есть еще одна функция **`wrapped`**, которая уже давно ждет свой час чтобы занять место оригинальной функции **`say_hello`**. Она будет возвращаться фукнцией **`decorator`** и хранить оригинальный вызов **`say_hello`**, а также принимать и передавать нужные для нее параметры с помощью `*args` и `**kwargs`.

Таким образом мы разобрались как будет работать декоратор с параметрами.

### Декоратор с параметрами, но без них
#### Или от декораторов с параметрами до декораторов без параметров один шаг
Все шло хорошо, пока мы вызывали **`sleeper`** передавая ему значение для параметра `secs`:

    @sleeper(10)
    def say_hello(name):
        ...

В таком случае **`say_hello`** уже хранит ссылку на функцию **`wrapped`** которая ее обернула:

    >>> say_hello.func_name
    'wrapped'

Но что если написать следующим образом:

    @sleeper
    def say_hello(name):
        ...

На первый взгляд можно ожидать TypeError с сообщением о том, что функция **`sleeper`** принимает один обязательный параметр. Но на самом деле программа отработает без ошибок.

Даже можно сделать так:

    say_hello('world')

Корректного результата ждать здесь не стоит. На экране не появится сообщение `Hello world!`. Посмотрим что покажет `func_name`:

    >>> say_hello.func_name
    'decorator'

Вернемся к явной конструкции вызова декораторов для получения того же результата:

    >>> say_hello = sleeper(say_hello)
    >>> say_hello.func_name
    'decorator'

Выходит так, что **`sleeper`** принимает в качестве параметра вместо количества секунд задержки, изначальную функцию **`say_hello`**. То есть декоратор с параметрами повел себя как декоратор без параметров.

До функции **`wrapped`** можно добраться таким образом:

    >>> say_hello('world').func_name
    'wrapped'

Получилось что **`say_hello`** ссылается на **`decorator`** который принял вместо функции `fn` строку `'world'` и вернул **`wrapped`**. Теперь мы можем вызвать тот самый **`wrapped`**:

    >>> say_hello('world')()
   
Но получим TypeError, в данном случае уже от стандартной функции `sleep`, которая примет в качестве аргумента `secs` функцию **`say_hello`** вместо количества секунд задержки.